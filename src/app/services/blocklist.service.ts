import { Injectable } from '@angular/core';
import { IBlocklistItem } from '../interfaces/IBlocklistItem';
import { GitService } from './git.service';
import { GithubService } from './github.service';

@Injectable({
  providedIn: 'root'
})
export class BlocklistService {

  /**
   * The DNS blocklist.
   */
  public ipDnsBlocklist: Array<IBlocklistItem> = [];

  private createNestedFolderList(prefix: string, ipText: string, ipVersion: 'ipv4' | 'ipv6') {
    const split = ipVersion === 'ipv4' ? '.' : ':';
    const splitByVer = ipText.split(split).map(item => !item ?  '0' : item ); // Includes _ for IPV6
    const totalSplits = splitByVer.length;
    return new Array(splitByVer.length).fill(splitByVer)
      .reduce((iter, frag, idx) => {
        iter.push(
          `${prefix}${frag.slice(0, totalSplits - idx).join(split)}`
        );
        return iter;
      }, []);
  }

  private checkItemExists(ipAddress: string, items: Array<IBlocklistItem>, ipVersion: 'ipv4' | 'ipv6' = 'ipv4') {
    const found = items.find((item: IBlocklistItem) => item[ipVersion] === ipAddress);
    return found;
  }

  private async appendOrAddToFile(path: string, item: IBlocklistItem, ipVersion: 'ipv4' | 'ipv6' = 'ipv4') {
    let existingFile;

    try {
      const items = (await this.GitService.getGitFile(`${path}/blocklist.json`)).toString();

      if (this.checkItemExists(item[ipVersion] as string, JSON.parse(items))) {
        return null;
      }
      existingFile = items;
    } catch {
      existingFile = JSON.stringify([item]);
    }

    return {
      path: `${path}/blocklist.json`,
      content: existingFile
    };
  }

  /**
   * Ensures that an IP blocklist exists and is partitioned.
   * @param ipVersion
   * @param ipAddress
   */
  private async addItemToAllPaths(item: IBlocklistItem, ipVersion: 'ipv4' | 'ipv6' = 'ipv4') {
    const allPathsToEnsure = this.createNestedFolderList(`blocklist/DNS/${ipVersion}/`, item[ipVersion] as string, ipVersion);

    const withExtraPaths = [
      ...allPathsToEnsure,
      `blocklist/DNS/${ipVersion}`
    ];

    const response = await Promise.allSettled(
      withExtraPaths.map((path: string) => this.appendOrAddToFile(path, item, ipVersion))
    );

    const changes = response.filter(({ status }) => status === 'fulfilled')
      .map((response: any) => ({
        files: {
          [response.value.path]: response.value.content
        },
        commit: 'AntiScamBL AutoGen'
      }));

    await this.GithubService.createPullRequest(
      `Adding ${item.ipv4 ?? item.ipv6} to ${item.ipv4 ? 'ipv4' : 'ipv6 blocklist'}`,
      `This Pull Request was automatically generated by AntiScamBL's UI. This PR request will be reviewed in due course by a user with permissions to this repository and when approved and merged, the record will go live on the DNSBL.`, 
      `DNSBL-Add-${item.id}-AutoGen`, changes);
  }
  
  /**
   * Adds the item to a given blocklist. 
   * @param item 
   */
  public async addItemToBlocklist(item: IBlocklistItem) {
    item.ipv4 && await this.addItemToAllPaths(item, 'ipv4');
    item.ipv6 && await this.addItemToAllPaths(item, 'ipv6');
  }

  /**
   * Initialises the git repo and gets the blocklist file.
   */
  private async initGitRepo() {
    // Clone the repo and get the contents locally
    await this.GitService.cloneRepo();

    // Gets the blocklist file as string.
    const blocklistFile = (await this.GitService.getGitFile('/blocklist/blocklist/DNS/blocklist.json')).toString();
    this.ipDnsBlocklist = JSON.parse(blocklistFile);
  }

  private init() {
    (async () => {
      await this.initGitRepo();
    })().then(() => {}).catch((err) => {});
  }

  /**
   * Creates a new instance of the GitService.
   * @param GitService
   */
  constructor(private readonly GithubService: GithubService, private readonly GitService: GitService) {
    this.init();
  }
}
